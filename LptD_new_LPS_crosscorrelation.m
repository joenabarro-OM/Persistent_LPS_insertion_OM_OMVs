% LptD_new_LPS_crosscorrelation.txt
%
% Radial spatial cross-correlation g(r) between LptD* (reference) and newly inserted LPS (target)
% from two-colour dSTORM localisation data.
%
%
%   - PCA alignment (SVD) to align the long axis of the cell with the x-axis
%   - Bin width set to 1.5 × median localisation precision across both channels (rounded to nearest 10 nm)
%   - Maximum radial displacement set to 50% of the larger cell dimension (length/width)
%   - Null distribution generated by randomising LPS coordinates within the same cell envelope boundary
%     (approximated here as a capsule/obround defined by the PCA-aligned localisation extents)
%   - g(r) computed as: observed pair counts / expected pair counts under the null model, per radial shell
%
% INPUTS:
%   Two CSV files exported from ZEN (one per channel), e.g.:
%     - LptD_488.csv (LptD*)
%     - LPS_647.csv  (newly inserted LPS)
%   Required columns (common ZEN names supported):
%     - Position X [nm]   or PositionX_nm_
%     - Position Y [nm]   or PositionY_nm_
%     - Precision [nm]    or Precision_nm_   (recommended; required unless binWidth_nm is set manually)
%   If your photon counts are present, they are not used for g(r) in this implementation.
%
% OUTPUTS (saved to outputDir):
%   - radial_gr_<tag>.csv
%       Radius_nm, g_r, ObservedPairs, ExpectedPairs, binWidth_nm, maxRadius_nm, cellLength_nm, cellWidth_nm, medianPrecision_nm
%   - radial_gr_metrics_<tag>.csv
%       half_max, r_half_max_nm, gr_max, r_max_nm
%   - gr_plot_<tag>.png
%
% DEPENDENCIES:
%   - MATLAB R2020b+ (tested with R2024b). No toolboxes required.
%
% Author: Joe Nabarro
% Contact: joe.nabarro@york.ac.uk
% Institution: University of York
% -------------------------------------------------------------------------
clear; clc;

%% USER SETTINGS (edit as needed)
lptdCsv = 'LptD_488.csv';   % LptD* (reference channel)
lpsCsv  = 'LPS_647.csv';    % newly inserted LPS (target channel)

outputDir = 'crosscorr_output';
rngSeed   = 1;              % set for reproducibility

% If localisation precision is not available in the input tables, set this manually (nm).
% Leave as NaN to use per-localisation Precision column.
manualMedianPrecision_nm = NaN;

% Null-model settings
nNull   = 20;               % number of randomisations (increase to reduce noise)
export2DMaps = false;       % set true to export 2D maps (large files)

%% LOAD LOCALISATIONS
LptD = standardiseZenTable(readtable(lptdCsv));
LPS  = standardiseZenTable(readtable(lpsCsv));

X1 = LptD.X_nm;  Y1 = LptD.Y_nm;
X2 = LPS.X_nm;   Y2 = LPS.Y_nm;

if isempty(X1) || isempty(X2)
    error('One or both input files contain no localisations after parsing.');
end

%% PCA ALIGNMENT (SVD) USING BOTH CHANNELS
allXY = [X1(:), Y1(:); X2(:), Y2(:)];
allXY = allXY - mean(allXY, 1, 'omitnan');

[~, ~, V] = svd(allXY, 'econ');   % principal axes in columns of V
R = V;                             % rotation matrix

XY1 = ([X1(:), Y1(:)] - mean([X1(:), Y1(:); X2(:), Y2(:)], 1, 'omitnan')) * R;
XY2 = ([X2(:), Y2(:)] - mean([X1(:), Y1(:); X2(:), Y2(:)], 1, 'omitnan')) * R;

X1 = XY1(:,1); Y1 = XY1(:,2);
X2 = XY2(:,1); Y2 = XY2(:,2);

%% ESTIMATE CELL DIMENSIONS (PCA-aligned) AND SET BINNING
cellLength_nm = max([X1; X2]) - min([X1; X2]);
cellWidth_nm  = max([Y1; Y2]) - min([Y1; Y2]);

% Median localisation precision (nm)
if isfinite(manualMedianPrecision_nm)
    medianPrecision_nm = manualMedianPrecision_nm;
else
    if isempty(LptD.Precision_nm) || isempty(LPS.Precision_nm)
        error(['Precision column not found. Either include Precision [nm] in the input CSVs ', ...
               'or set manualMedianPrecision_nm in USER SETTINGS.']);
    end
    medianPrecision_nm = median([LptD.Precision_nm(:); LPS.Precision_nm(:)], 'omitnan');
end

% Bin width: 1.5 × median precision, rounded to nearest 10 nm (Methods)
binWidth_nm = round((1.5 * medianPrecision_nm) / 10) * 10;

% Max radial displacement: 50% of larger cell dimension (Methods)
maxRadius_nm = round((0.5 * max(cellLength_nm, cellWidth_nm)) / 10) * 10;

if binWidth_nm <= 0 || maxRadius_nm <= 0
    error('Derived binWidth_nm or maxRadius_nm is not valid.');
end


% We approximate the cell envelope as a capsule using the PCA-aligned extents
% of the combined localisation cloud. This provides a consistent boundary for
% LPS randomisation in the null model while preserving cell geometry.
cap = capsuleFromExtents([X1; X2], [Y1; Y2]);


% Displacements from each LptD localisation to all LPS localisations.
edges = -maxRadius_nm:binWidth_nm:maxRadius_nm;
obs2D = pairDisplacementHistogram2D(X1, Y1, X2, Y2, edges);


rng(rngSeed);
exp2D_accum = zeros(size(obs2D));

nTarget = numel(X2);
for k = 1:nNull
    [X2r, Y2r] = sampleUniformInCapsule(nTarget, cap);
    exp2D_accum = exp2D_accum + pairDisplacementHistogram2D(X1, Y1, X2r, Y2r, edges);
end
exp2D = exp2D_accum ./ nNull;


rEdges   = 0:binWidth_nm:maxRadius_nm;
rCenters = rEdges(1:end-1) + binWidth_nm/2;

% Grid of bin-centre radii for mapping 2D bins to radial shells
[dxc, dyc] = meshgrid(rCentersSigned(edges), rCentersSigned(edges));
rr = sqrt(dxc.^2 + dyc.^2);

ObservedPairs = zeros(numel(rCenters),1);
ExpectedPairs = zeros(numel(rCenters),1);
g_r          = nan(numel(rCenters),1);

for i = 1:numel(rCenters)
    inShell = (rr >= rEdges(i)) & (rr < rEdges(i+1));
    obsCount = sum(obs2D(inShell), 'omitnan');
    expCount = sum(exp2D(inShell), 'omitnan');

    ObservedPairs(i) = obsCount;
    ExpectedPairs(i) = expCount;

    if expCount > 0
        g_r(i) = obsCount / expCount;
    else
        g_r(i) = NaN;
    end
end

%% Summary_metrics: Half_max AND r_half-max
[gr_max, idx_max] = max(g_r, [], 'omitnan');
r_max_nm = rCenters(idx_max);

half_max = 0.5 * gr_max;
r_half_max_nm = NaN;

if isfinite(gr_max)
    % Find first radius after the peak where g(r) falls to <= half_max
    for j = idx_max:numel(g_r)
        if isfinite(g_r(j)) && g_r(j) <= half_max
            r_half_max_nm = rCenters(j);
            break;
        end
    end
end

%% Export
if ~exist(outputDir, 'dir')
    mkdir(outputDir);
end

tag = makeTagFromFilenames(lptdCsv, lpsCsv);

outTable = table( ...
    rCenters(:), g_r(:), ObservedPairs(:), ExpectedPairs(:), ...
    repmat(binWidth_nm, numel(rCenters), 1), repmat(maxRadius_nm, numel(rCenters), 1), ...
    repmat(cellLength_nm, numel(rCenters), 1), repmat(cellWidth_nm, numel(rCenters), 1), ...
    repmat(medianPrecision_nm, numel(rCenters), 1), ...
    'VariableNames', {'Radius_nm','g_r','ObservedPairs','ExpectedPairs', ...
                      'binWidth_nm','maxRadius_nm','cellLength_nm','cellWidth_nm','medianPrecision_nm'} );

writetable(outTable, fullfile(outputDir, sprintf('radial_gr_%s.csv', tag)));

metricsTable = table(half_max, r_half_max_nm, gr_max, r_max_nm, ...
    'VariableNames', {'half_max','r_half_max_nm','gr_max','r_max_nm'});
writetable(metricsTable, fullfile(outputDir, sprintf('radial_gr_metrics_%s.csv', tag)));

% Minimal plot (no custom styling)
fig = figure('Color','w','Units','centimeters','Position',[2 2 14 10]);
plot(rCenters, g_r, 'k-', 'LineWidth', 1.5);
xlabel('Radial distance (nm)');
ylabel('g(r)');
set(gca, 'TickDir','out', 'Box','off');
xlim([0 maxRadius_nm]);
exportgraphics(fig, fullfile(outputDir, sprintf('gr_plot_%s.png', tag)), 'Resolution', 600);
close(fig);

if export2DMaps
    writematrix(obs2D, fullfile(outputDir, sprintf('obs2D_counts_%s.csv', tag)));
    writematrix(exp2D, fullfile(outputDir, sprintf('exp2D_counts_%s.csv', tag)));
    g2D = obs2D ./ exp2D;
    g2D(~isfinite(g2D)) = NaN;
    writematrix(g2D, fullfile(outputDir, sprintf('g2D_%s.csv', tag)));
end

disp("Done: outputs saved to " + outputDir);


function S = standardiseZenTable(T)
%Standardisable Parse common ZEN localisation table columns into X/Y/Precision.
    vars = string(T.Properties.VariableNames);

    xVar = pickVar(vars, ["Position X [nm]","PositionX_nm_","PositionX_nm","X_nm","X [nm]"]);
    yVar = pickVar(vars, ["Position Y [nm]","PositionY_nm_","PositionY_nm","Y_nm","Y [nm]"]);
    pVar = pickVar(vars, ["Precision [nm]","Precision_nm_","Precision_nm","Precision"]);

    if xVar == "" || yVar == ""
        error("Input CSV must contain Position X [nm] and Position Y [nm] (or equivalent).");
    end

    S = struct();
    S.X_nm = double(T.(xVar));
    S.Y_nm = double(T.(yVar));

    if pVar ~= ""
        S.Precision_nm = double(T.(pVar));
    else
        S.Precision_nm = [];
    end
end

function v = pickVar(vars, candidates)
%PICKVAR Return the first matching variable name from candidates, else "".
    v = "";
    for k = 1:numel(candidates)
        idx = find(strcmpi(vars, candidates(k)), 1, 'first');
        if ~isempty(idx)
            v = vars(idx);
            return;
        end
    end
end

function cap = capsuleFromExtents(x, y)
% Define capsule parameters from PCA-aligned extents.
    xmin = min(x); xmax = max(x);
    ymin = min(y); ymax = max(y);

    cap.cx = (xmin + xmax) / 2;
    cap.cy = (ymin + ymax) / 2;

    cap.length = (xmax - xmin);
    cap.width  = (ymax - ymin);

    cap.radius = cap.width / 2;
    cap.halfLength = cap.length / 2;

    % Ensure physically valid capsule: length >= width
    if cap.length < cap.width
        % Swap interpretation if localisation cloud is wider than long-axis extent
        cap.length = cap.width;
        cap.width  = cap.length;
        cap.radius = cap.width / 2;
        cap.halfLength = cap.length / 2;
    end

    cap.cylHalfLength = max(0, cap.halfLength - cap.radius);
end

function [xr, yr] = sampleUniformInCapsule(n, cap)
% Uniform sampling inside a capsule (cylinder + two semicircles).
    xr = zeros(n,1);
    yr = zeros(n,1);

    r = cap.radius;
    Lc = cap.cylHalfLength;

    % Area fractions
    areaRect = (2*Lc) * (2*r);
    areaCir  = pi * r^2;
    pRect = areaRect / (areaRect + areaCir);

    for i = 1:n
        if rand < pRect
            % Sample in rectangle (cylinder projection)
            xr(i) = (rand*2 - 1) * Lc;
            yr(i) = (rand*2 - 1) * r;
        else
            % Sample in full circle then shift to left or right cap
            theta = 2*pi*rand;
            rad = r*sqrt(rand);
            x0 = rad*cos(theta);
            y0 = rad*sin(theta);

            if x0 >= 0
                xr(i) = x0 + Lc;  % right cap
            else
                xr(i) = x0 - Lc;  % left cap
            end
            yr(i) = y0;
        end
    end

    xr = xr + cap.cx;
    yr = yr + cap.cy;
end

function H = pairDisplacementHistogram2D(Xref, Yref, Xtar, Ytar, edges)
%Count pairwise displacement vectors (target - reference) on a square grid.
    nBins = numel(edges) - 1;
    H = zeros(nBins, nBins);

    for i = 1:numel(Xref)
        dx = Xtar - Xref(i);
        dy = Ytar - Yref(i);

        % Keep only displacements inside the square window
        in = (dx >= edges(1)) & (dx < edges(end)) & (dy >= edges(1)) & (dy < edges(end));
        if ~any(in)
            continue;
        end

        % 2D histogram on edges
        Hi = histcounts2(dy(in), dx(in), edges, edges); % rows = y, cols = x
        H = H + Hi;
    end
end

function centers = rCentersSigned(edges)
% Bin centres for signed displacement axes given edges.
    centers = edges(1:end-1) + (edges(2)-edges(1))/2;
end

function tag = makeTagFromFilenames(f1, f2)
% Create a simple tag from input filenames.
    [~, a, ~] = fileparts(f1);
    [~, b, ~] = fileparts(f2);
    a = regexprep(a, '[^a-zA-Z0-9]+', '_');
    b = regexprep(b, '[^a-zA-Z0-9]+', '_');
    tag = sprintf('%s__%s', a, b);
end
